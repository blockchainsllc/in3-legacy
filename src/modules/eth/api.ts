import Client from '../../client/Client'
import { methodID, rawEncode, rawDecode } from 'ethereumjs-abi'
import { toChecksumAddress, privateToAddress, keccak, ecsign } from 'ethereumjs-util'
import * as ETx from 'ethereumjs-tx'
import { toHex, toNumber, toBN, toBuffer, toMinHex } from '../../util/util'
import { bytes32, bytes, address } from './serialize';
import BN = require('bn.js')
import { AbiCoder } from '@ethersproject/abi'
import { RPCResponse } from '../../types/types';

export type BlockType = number | 'latest' | 'earliest' | 'pending'
export type Hex = string
export type Quantity = number | Hex
export type Hash = Hex
export type Address = Hex
export type Data = Hex

export type Signature = {
    message: Data
    messageHash: Hash
    v: Hex
    r: Hash
    s: Hash
    signature?: Data
}

export type ABIField = {
    indexed?: boolean
    name: string
    type: string
}
export type ABI = {
    anonymous?: boolean
    constant?: boolean
    payable?: boolean
    stateMutability?: 'nonpayable' | 'payable' | 'view' | 'pure'

    inputs?: ABIField[],
    outputs?: ABIField[]
    name?: string
    type: 'event' | 'function' | 'constructor' | 'fallback'
}
export type Transaction = {
    /** 20 Bytes - The address the transaction is send from. */
    from: Address
    /** (optional when creating new contract) 20 Bytes - The address the transaction is directed to.*/
    to: Address
    /** Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter may be needed by some executions. */
    gas: Quantity
    /** Integer of the gas price used for each paid gas.  */
    gasPrice: Quantity
    /** Integer of the value sent with this transaction. */
    value: Quantity
    /** 4 byte hash of the method signature followed by encoded parameters. For details see Ethereum Contract ABI.*/
    data: string
    /** nonce */
    nonce: Quantity
    /** optional chain id */
    chainId?: any
}
export type TransactionReceipt = {
    /** 32 Bytes - hash of the block where this transaction was in. */
    blockHash: Hash
    /** block number where this transaction was in.*/
    blockNumber: BlockType
    /** 20 Bytes - The contract address created, if the transaction was a contract creation, otherwise null.*/
    contractAddress: Address
    /** The total amount of gas used when this transaction was executed in the block. */
    cumulativeGasUsed: Quantity
    /** 20 Bytes - The address of the sender. */
    from: Address
    /** 20 Bytes - The address of the receiver. null when it’s a contract creation transaction.*/
    to: Address
    /** The amount of gas used by this specific transaction alone. */
    gasUsed: Quantity
    /** Array of log objects, which this transaction generated. */
    logs: Log[]
    /** 256 Bytes - A bloom filter of logs/events generated by contracts during transaction execution. Used to efficiently rule out transactions without expected logs.*/
    logsBloom: Data
    /** 32 Bytes - Merkle root of the state trie after the transaction has been executed (optional after Byzantium hard fork EIP609)*/
    root: Hash
    /** 0x0 indicates transaction failure , 0x1 indicates transaction success. Set for blocks mined after Byzantium hard fork EIP609, null before. */
    status: Quantity
    /** 32 Bytes - hash of the transaction. */
    transactionHash: Hash
    /** Integer of the transactions index position in the block. */
    transactionIndex: Quantity
}
export type TransactionDetail = {
    /**  32 Bytes - hash of the transaction. */
    hash: Hash
    /** the number of transactions made by the sender prior to this one.*/
    nonce: Quantity
    /** 32 Bytes - hash of the block where this transaction was in. null when its pending.*/
    blockHash: Hash
    /** block number where this transaction was in. null when its pending.*/
    blockNumber: BlockType
    /** integer of the transactions index position in the block. null when its pending.*/
    transactionIndex: Quantity
    /** 20 Bytes - address of the sender.*/
    from: Address
    /** 20 Bytes - address of the receiver. null when its a contract creation transaction. */
    to: Address
    /**  value transferred in Wei.*/
    value: Quantity
    /** gas price provided by the sender in Wei.*/
    gasPrice: Quantity
    /** gas provided by the sender. */
    gas: Quantity
    /** the data send along with the transaction. */
    input: Data
    /** the standardised V field of the signature.*/
    v: Quantity
    /** the standardised V field of the signature (0 or 1).*/
    standardV: Quantity
    /** the R field of the signature.*/
    r: Quantity
    /** raw transaction data */
    raw: Data
    /** public key of the signer. */
    publicKey: Hash
    /** the chain id of the transaction, if any. */
    chainId: Quantity
    /** creates contract address */
    creates: Address
    /** (optional) conditional submission, Block number in block or timestamp in time or null. (parity-feature)    */
    condition: any
    /** optional: the private key to use for signing */
    pk?: any
}

export type Block = {
    /**  The block number. null when its pending block */
    number: Quantity
    /** hash of the block. null when its pending block */
    hash: Hash
    /** hash of the parent block */
    parentHash: Hash
    /** 8 bytes hash of the generated proof-of-work. null when its pending block. Missing in case of PoA. */
    nonce: Data
    /** SHA3 of the uncles data in the block */
    sha3Uncles: Data
    /** 256 Bytes - the bloom filter for the logs of the block. null when its pending block */
    logsBloom: Data
    /** 32 Bytes - the root of the transaction trie of the block */
    transactionsRoot: Data
    /** 32 Bytes - the root of the final state trie of the block */
    stateRoot: Data
    /** 32 Bytes - the root of the receipts trie of the block */
    receiptsRoot: Data
    /** 20 Bytes - the address of the author of the block (the beneficiary to whom the mining rewards were given)*/
    author: Address
    /** 20 Bytes - alias of ‘author’*/
    miner: Address
    /** integer of the difficulty for this block */
    difficulty: Quantity
    /** integer of the total difficulty of the chain until this block */
    totalDifficulty: Quantity
    /** the ‘extra data’ field of this block */
    extraData: Data
    /** integer the size of this block in bytes */
    size: Quantity
    /** the maximum gas allowed in this block */
    gasLimit: Quantity
    /** the total used gas by all transactions in this block */
    gasUsed: Quantity
    /** the unix timestamp for when the block was collated */
    timestamp: Quantity
    /** Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter */
    transactions: (Hash | Transaction)[]
    /** Array of uncle hashes */
    uncles: Hash[]
    /** PoA-Fields */
    sealFields: Data[]
}
export type Log = {
    /** true when the log was removed, due to a chain reorganization. false if its a valid log. */
    removed: boolean
    /** integer of the log index position in the block. null when its pending log. */
    logIndex: Quantity
    /** integer of the transactions index position log was created from. null when its pending log. */
    transactionIndex: Quantity
    /** Hash, 32 Bytes - hash of the transactions this log was created from. null when its pending log. */
    transactionHash: Hash
    /** Hash, 32 Bytes - hash of the block where this log was in. null when its pending. null when its pending log. */
    blockHash: Hash,
    /** the block number where this log was in. null when its pending. null when its pending log. */
    blockNumber: Quantity
    /** 20 Bytes - address from which this log originated. */
    address: Address,
    /**  contains the non-indexed arguments of the log. */
    data: Data
    /** - Array of 0 to 4 32 Bytes DATA of indexed log arguments. (In solidity: The first topic is the hash of the signature of the event (e.g. Deposit(address,bytes32,uint256)), except you declared the event with the anonymous specifier.) */
    topics: Data[]
}

export type LogFilter = {
    /**  Quantity or Tag - (optional) (default: latest) Integer block number, or 'latest' for the last mined block or 'pending', 'earliest' for not yet mined transactions. */
    fromBlock: BlockType
    /** Quantity or Tag - (optional) (default: latest) Integer block number, or 'latest' for the last mined block or 'pending', 'earliest' for not yet mined transactions.*/
    toBlock: BlockType
    /** (optional) 20 Bytes - Contract address or a list of addresses from which logs should originate.*/
    address: Address
    /** (optional) Array of 32 Bytes Data topics. Topics are order-dependent. It’s possible to pass in null to match any topic, or a subarray of multiple topics of which one should be matching. */
    topics: (string | string[])[]
    /** å(optional) The maximum number of entries to retrieve (latest first). */
    limit: Quantity
}

export type TxRequest = {
    /** contract */
    to?: Address

    /** address of the account to use */
    from?: Address

    /** the data to send */
    data?: Data

    /** the gas needed */
    gas?: number

    /** the gasPrice used */
    gasPrice?: number

    /** the nonce */
    nonce?: number

    /** the value in wei */
    value?: Quantity

    /** the ABI of the method to be used */
    method?: string

    /** the argument to pass to the method */
    args?: any[]

    /**raw private key in order to sign */
    pk?: Hash

    /**  number of block to wait before confirming*/
    confirmations?: number
}

export interface Signer {
    /** optiional method which allows to change the transaction-data before sending it. This can be used for redirecting it through a multisig. */
    prepareTransaction?: (client: Client, tx: Transaction) => Promise<Transaction>

    /** returns true if the account is supported (or unlocked) */
    hasAccount(account: Address): Promise<boolean>

    /** signing of any data. */
    sign: (data: Buffer, account: Address) => Promise<Signature>
}


export default class EthAPI {
    client: Client
    signer?: Signer

    constructor(client: Client) { this.client = client }

    private send<T>(name: string, ...params: any[]): Promise<T> {
        return this.client.sendRPC(name, params || [])
            .then(r => {
                if (r.error) throw new Error((r.error as any).message || r.error)
                return r.result as T
            })
    }

    /**
     * Returns the number of most recent block. (as number)
     */
    blockNumber(): Promise<number> {
        return this.send<string>('eth_blockNumber').then(parseInt)
    }
    /**
     * Returns the current price per gas in wei. (as number)
     */
    gasPrice(): Promise<number> {
        return this.send<string>('eth_gasPrice').then(parseInt)
    }

    /**
     * Executes a new message call immediately without creating a transaction on the block chain.
     */
    call(tx: Transaction, block: BlockType = 'latest'): Promise<string> {
        return this.send<string>('eth_call', tx, toHexBlock(block))
    }

    /**
     * Executes a function of a contract, by passing a [method-signature](https://github.com/ethereumjs/ethereumjs-abi/blob/master/README.md#simple-encoding-and-decoding) and the arguments, which will then be ABI-encoded and send as eth_call. 
     */
    callFn(to: Address, method: string, ...args: any[]): Promise<any> {
        const t = createCallParams(method, args || [])
        return this.send('eth_call', { to, data: t.txdata }, 'latest').then(t.convert)
    }

    /**
     * Returns the EIP155 chain ID used for transaction signing at the current best block. Null is returned if not available.
     */
    chainId(): Promise<string> {
        return this.send<string>('eth_chainId')
    }

    /**
     * Makes a call or transaction, which won’t be added to the blockchain and returns the used gas, which can be used for estimating the used gas.
     */
    estimateGas(tx: Transaction/*, block: BlockType = 'latest'*/): Promise<number> {
        return this.send<string>('eth_estimateGas', tx/*, toHexBlock(block)*/).then(parseInt)
    }

    /**
     * Returns the balance of the account of given address in wei (as hex).
     */
    getBalance(address: Address, block: BlockType = 'latest'): Promise<BN> {
        return this.send<string>('eth_getBalance', address, toHexBlock(block)).then(toBN)
    }

    /**
     * Returns code at a given address.
     */
    getCode(address: Address, block: BlockType = 'latest'): Promise<string> {
        return this.send<string>('eth_getCode', address, block)
    }


    /**
     * Returns the value from a storage position at a given address.
     */
    getStorageAt(address: Address, pos: Quantity, block: BlockType = 'latest'): Promise<string> {
        return this.send<string>('eth_getStorageAt', address, pos, toHexBlock(block))
    }


    /**
     * Returns information about a block by hash.
     */
    getBlockByHash(hash: Hash, includeTransactions = false): Promise<Block> {
        return this.send<Block>('eth_getBlockByHash', hash, includeTransactions)
    }

    /**
     * Returns information about a block by block number.
     */
    getBlockByNumber(block: BlockType = 'latest', includeTransactions = false): Promise<Block> {
        return this.send<Block>('eth_getBlockByNumber', toHexBlock(block), includeTransactions)
    }


    /**
     * Returns the number of transactions in a block from a block matching the given block hash.
     */
    getBlockTransactionCountByHash(block: Hash): Promise<number> {
        return this.send<string>('eth_getBlockTransactionCountByHash', block).then(parseInt)
    }


    /**
     * Returns the number of transactions in a block from a block matching the given block number.
     */
    getBlockTransactionCountByNumber(block: Hash): Promise<number> {
        return this.send<string>('eth_getBlockTransactionCountByNumber', block).then(parseInt)
    }

    /**
     * Polling method for a filter, which returns an array of logs which occurred since last poll.
     */
    getFilterChanges(id: Quantity): Promise<Log[]> {
        return this.send<Log[]>('eth_getFilterChanges', id)
    }

    /**
     * Returns an array of all logs matching filter with given id.
     */
    getFilterLogs(id: Quantity): Promise<Log[]> {
        return this.send<Log[]>('eth_getFilterLogs', id)
    }

    /**
     * Returns an array of all logs matching a given filter object.
     */
    getLogs(filter: LogFilter): Promise<Log[]> {
        if (filter.fromBlock) filter.fromBlock = toHexBlock(filter.fromBlock) as BlockType
        if (filter.toBlock) filter.toBlock = toHexBlock(filter.toBlock) as BlockType
        if (filter.limit) filter.limit = toNumber(filter.limit)
        return this.send<Log[]>('eth_getLogs', filter)
    }




    /**
     * Returns information about a transaction by block hash and transaction index position.
     */
    getTransactionByBlockHashAndIndex(hash: Hash, pos: Quantity): Promise<TransactionDetail> {
        return this.send<TransactionDetail>('eth_getTransactionByBlockHashAndIndex', hash, pos)
    }


    /**
     * Returns information about a transaction by block number and transaction index position.
     */
    getTransactionByBlockNumberAndIndex(block: BlockType, pos: Quantity): Promise<TransactionDetail> {
        return this.send<TransactionDetail>('eth_getTransactionByBlockNumberAndIndex', toHexBlock(block), pos)
    }

    /**
     * Returns the information about a transaction requested by transaction hash.
     */
    getTransactionByHash(hash: Hash): Promise<TransactionDetail> {
        return this.send<TransactionDetail>('eth_getTransactionByHash', hash)
    }

    /**
     * Returns the number of transactions sent from an address. (as number)
     */
    getTransactionCount(address: Address, block: BlockType = 'latest'): Promise<number> {
        return this.send<string>('eth_getTransactionCount', address, block).then(parseInt)
    }

    /**
     * Returns the receipt of a transaction by transaction hash.
     * Note That the receipt is available even for pending transactions.
     */
    getTransactionReceipt(hash: Hash): Promise<TransactionReceipt> {
        return this.send<TransactionReceipt>('eth_getTransactionReceipt', hash).then(_ => !_ ? null : ({
            ..._,
            contractAddress: _.contractAddress && toChecksumAddress(_.contractAddress),
            from: _.from && toChecksumAddress(_.from)
        }))
    }

    /**
     * Returns information about a uncle of a block by hash and uncle index position.
     * Note: An uncle doesn’t contain individual transactions.
     */
    getUncleByBlockHashAndIndex(hash: Hash, pos: Quantity): Promise<Block> {
        return this.send<Block>('eth_getUncleByBlockHashAndIndex', hash, pos)
    }


    /**
     * Returns information about a uncle of a block number and uncle index position.
     * Note: An uncle doesn’t contain individual transactions.
     */
    getUncleByBlockNumberAndIndex(block: BlockType, pos: Quantity): Promise<Block> {
        return this.send<Block>('eth_getUncleByBlockNumberAndIndex', block, pos)
    }

    /**
     * Returns the number of uncles in a block from a block matching the given block hash.
     */
    getUncleCountByBlockHash(hash: Hash): Promise<number> {
        return this.send<string>('eth_getUncleCountByBlockHash', hash).then(parseInt)
    }

    /**
     * Returns the number of uncles in a block from a block matching the given block hash.
     */
    getUncleCountByBlockNumber(block: BlockType): Promise<number> {
        return this.send<string>('eth_getUncleCountByBlockNumber', block).then(parseInt)
    }


    /**
     * Creates a filter in the node, to notify when a new block arrives. To check if the state has changed, call eth_getFilterChanges.
     */
    newBlockFilter(): Promise<string> {
        return this.send<string>('eth_newBlockFilter')
    }


    /**
     * Creates a filter object, based on filter options, to notify when the state changes (logs). To check if the state has changed, call eth_getFilterChanges.
     * 
     * A note on specifying topic filters:
     * Topics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic filters:
     * 
     * [] “anything”
     * [A] “A in first position (and anything after)”
     * [null, B] “anything in first position AND B in second position (and anything after)”
     * [A, B] “A in first position AND B in second position (and anything after)”
     * [[A, B], [A, B]] “(A OR B) in first position AND (A OR B) in second position (and anything after)”
     */
    newFilter(filter: LogFilter): Promise<string> {
        return this.send<string>('eth_newFilter', filter)
    }

    /**
     * Creates a filter in the node, to notify when new pending transactions arrive.
     * 
     * To check if the state has changed, call eth_getFilterChanges.
     */
    newPendingTransactionFilter(): Promise<string> {
        return this.send<string>('eth_newPendingTransactionFilter')
    }


    /**
     * Uninstalls a filter with given id. Should always be called when watch is no longer needed. Additonally Filters timeout when they aren’t requested with eth_getFilterChanges for a period of time.
     */
    uninstallFilter(id: Quantity): Promise<Quantity> {
        return this.send<Quantity>('eth_uninstallFilter')
    }

    /**
     * Returns the current ethereum protocol version.
     */
    protocolVersion(): Promise<string> {
        return this.send<string>('eth_protocolVersion')
    }

    /**
      * Returns the current ethereum protocol version.
      */
    syncing(): Promise<boolean | {
        startingBlock: Hex,
        currentBlock: Hex,
        highestBlock: Hex
        blockGap: Hex[][]
        warpChunksAmount: Hex
        warpChunksProcessed: Hex
    }> {
        return this.send<boolean | {
            startingBlock: string,
            currentBlock: string,
            highestBlock: string
            blockGap: string[][]
            warpChunksAmount: string
            warpChunksProcessed: string
        }>('eth_syncing')
    }


    /**
     * Creates new message call transaction or a contract creation for signed transactions.
     */
    sendRawTransaction(data: Data): Promise<string> {
        return this.send<string>('eth_sendRawTransaction', data)
    }

    /**
     * signs any kind of message using the `\x19Ethereum Signed Message:\n`-prefix
     * @param account the address to sign the message with (if this is a 32-bytes hex-string it will be used as private key)
     * @param data the data to sign (Buffer, hexstring or utf8-string)
     */
    async sign(account: Address, data: Data): Promise<Signature> {
        // prepare data
        const d = toBuffer(data)
        const hash = keccak(Buffer.concat([Buffer.from('\x19Ethereum Signed Message:\n' + d.length, 'utf8'), d]))
        let s: any = {
            message: data,
            messageHash: toHex(hash)
        }

        if (account && account.length == 66) // use direct pk
            s = { ...s, ...ecsign(hash, toBuffer(account)) }
        else if (this.signer && await this.signer.hasAccount(account)) // use signer
            s = { ...s, ...(await this.signer.sign(hash, account)) }
        s.signature = toHex(s.r) + toHex(s.s).substr(2) + toHex(s.v).substr(2)
        return s
    }

    /** sends a Transaction */
    async sendTransaction(args: TxRequest): Promise<string | TransactionReceipt> {
        if (!args.pk && (!this.signer || !(await this.signer.hasAccount(args.from)))) throw new Error('missing private key!')

        // prepare
        const tx = await prepareTransaction(args, this)
        let etx: any = null

        if (args.pk) {
            // sign it with the raw keyx
            etx = new ETx({ ...tx, gasLimit: tx.gas })
            etx.sign(toBuffer(args.pk))
        }
        else if (this.signer && args.from) {
            const t = this.signer.prepareTransaction ? await this.signer.prepareTransaction(this.client, tx) : tx
            etx = new ETx({ ...t, gasLimit: t.gas })
            const signature = await this.signer.sign(etx.hash(false), args.from)
            if (etx._chainId > 0) signature.v = toHex(toNumber(signature.v) + etx._chainId * 2 + 8)
            Object.assign(etx, signature)
        }
        else throw new Error('Invalid transaction-data')
        const txHash = await this.sendRawTransaction(toHex(etx.serialize()))

        if (args.confirmations === undefined) args.confirmations = 1

        // send it
        return args.confirmations ? confirm(txHash, this, parseInt(tx.gas as string), args.confirmations) : txHash
    }

    contractAt(abi: ABI[], address: Address): {
        [methodName: string]: any,
        _address: Address, _eventHashes: any, events: {
            [event: string]: {
                getLogs: (options: { limit?: number, fromBlock?: BlockType, toBlock?: BlockType, topics?: any[], filter?: { [key: string]: any } }) => Promise<{ [key: string]: any, event: string, log: Log }[]>
            }
            all: {
                getLogs: (options: { limit?: number, fromBlock?: BlockType, toBlock?: BlockType, topics?: any[], filter?: { [key: string]: any } }) => Promise<{ [key: string]: any, event: string, log: Log }[]>
            }
            decode: any
        }, _abi: ABI[], _in3: Client
    } {
        const api = this, ob = { _address: address, _eventHashes: {} as any, events: {} as any, _abi: abi, _in3: this.client }
        for (const def of abi.filter(_ => _.type == 'function')) {
            const method = def.name + createSignature(def.inputs)
            if (def.constant) {
                const signature = method + ':' + createSignature(def.outputs)
                ob[def.name] = function (...args: any[]) {
                    return api.callFn(address, signature, ...args)
                        .then(r => {
                            if (def.outputs.length > 1) {
                                let o = {}
                                def.outputs.forEach((d, i) => o[i] = o[d.name] = r[i])
                                return o;
                            }
                            return r
                        })
                }
            }
            else {
                ob[def.name] = function (...args: any[]) {
                    let tx: TxRequest = {} as any
                    if (args.length > def.inputs.length) tx = args.pop()
                    tx.method = method
                    tx.args = args.slice(0, def.name.length);
                    tx.confirmations = tx.confirmations || 1
                    tx.to = address
                    return api.sendTransaction(tx)
                }
            }
            ob[def.name].encode = (...args: any[]) => createCallParams(method, args.slice(0, def.name.length)).txdata
        }

        for (const def of abi.filter(_ => _.type == 'event')) {
            const eHash = '0x' + keccak(Buffer.from(def.name + createSignature(def.inputs), 'utf8')).toString('hex')
            ob._eventHashes[def.name] = eHash
            ob._eventHashes[eHash] = def
            ob.events[def.name] = {
                getLogs(options: { limit?: number, fromBlock?: BlockType, toBlock?: BlockType, topics?: any[], filter?: { [key: string]: any } } = {}) {
                    return api.getLogs({
                        address,
                        fromBlock: options.fromBlock || 'latest',
                        toBlock: options.toBlock || 'latest',
                        topics: options.topics || [eHash, ...(!options.filter ? [] : def.inputs.filter(_ => _.indexed).map(d => options.filter[d.name] ? '0x' + bytes32(options.filter[d.name]).toString('hex') : null))],
                        limit: options.limit || 50
                    }).then((logs: Log[]) => logs.map(_ => {
                        const event = ob.events.decode(_)
                        return { ...event, log: _, event }
                    }))
                }
            }
        }
        ob.events.decode = function (log: Log) { return decodeEventData(log, ob) }
        ob.events.all = {
            getLogs(options: { limit?: number, fromBlock?: BlockType, toBlock?: BlockType, topics?: any[] } = {}) {
                return api.getLogs({
                    address,
                    fromBlock: options.fromBlock || 'latest',
                    toBlock: options.toBlock || 'latest',
                    topics: options.topics || [],
                    limit: options.limit || 50
                }).then((logs: Log[]) => logs.map(_ => {
                    const event = ob.events.decode(_)
                    return { ...event, log: _, event }
                }))
            }
        }

        return ob as any
    }

    decodeEventData(log: Log, d: ABI): any {
        return decodeEvent(log, d)
    }
    hashMessage(data: Data | Buffer): Buffer {
        const d = toBuffer(data)
        return keccak(Buffer.concat([Buffer.from('\x19Ethereum Signed Message:\n' + d.length, 'utf8'), d]))
    }


}

async function confirm(txHash: Hash, api: EthAPI, gasPaid: number, confirmations: number, timeout = 10) {
    let steps = 200
    const start = Date.now()
    while (Date.now() - start < timeout * 1000) {
        const receipt = await api.getTransactionReceipt(txHash)
        if (receipt) {
            if (!receipt.status && gasPaid && gasPaid === parseInt(receipt.gasUsed as any))
                throw new Error('Transaction failed and all gas was used up gasPaid=' + gasPaid)
            if (receipt.status && receipt.status == '0x0')
                throw new Error('The Transaction failed because it returned status=0')

            if (confirmations > 1) {
                const start = parseInt(receipt.blockNumber as string)
                while (start + confirmations - 1 > await api.blockNumber())
                    await new Promise(_ => setTimeout(_, 10))

                return api.getTransactionReceipt(txHash)
            }
            return receipt
        }

        // wait a second and try again
        await new Promise(_ => setTimeout(_, Math.min(timeout * 200, steps *= 2)))
    }

    throw new Error('Error waiting for the transaction to confirm')
}

async function prepareTransaction(args: TxRequest, api?: EthAPI): Promise<Transaction> {
    const sender = args.from || (args.pk && toChecksumAddress(privateToAddress(toBuffer(args.pk)).toString('hex')))

    const tx: any = {}
    if (args.to) tx.to = toHex(args.to)
    if (args.method) {
        tx.data = createCallParams(args.method, args.args).txdata
        if (args.data) tx.data = args.data + tx.data.substr(10) // this is the case  for deploying contracts
    }
    else if (args.data)
        tx.data = toHex(args.data)
    if (sender || args.nonce)
        tx.nonce = toMinHex(args.nonce || (api && await api.getTransactionCount(sender, 'pending')))
    if (api)
        tx.gasPrice = toMinHex(args.gasPrice || Math.round(1.3 * toNumber(await api.gasPrice())))
    tx.value = toMinHex(args.value || 0)
    if (sender) tx.from = sender
    try {
        tx.gas = toMinHex(args.gas || (api && (toNumber(await api.estimateGas(tx)) + 1000) || 3000000))
    }
    catch (ex) {
        throw new Error('The Transaction ' + JSON.stringify(args, null, 2) + ' will not be succesfully executed, since estimating gas failed with: ' + ex)
    }


    return tx
}

function convertToType(solType: string, v: any): any {
    // check for arrays
    const list = solType.lastIndexOf('[')
    if (list >= 0) {
        if (!Array.isArray(v)) throw new Error('Invalid result for type ' + solType + '. Value must be an array, but is not!')
        solType = solType.substr(0, list)
        return v.map(_ => convertToType(solType, _))
    }

    // convert integers
    if (solType.startsWith('uint')) return parseInt(solType.substr(4)) <= 32 ? toNumber(v) : toBN(v)
    if (solType.startsWith('int')) return parseInt(solType.substr(3)) <= 32 ? toNumber(v) : toBN(v) // TODO handle negative values
    if (solType === 'bool') return typeof (v) === 'boolean' ? v : (toNumber(v) ? true : false)
    if (solType === 'string') return v.toString('utf8')
    if (solType === 'address') return toChecksumAddress('0x' + v)
    //    if (solType === 'bytes') return toBuffer(v)

    // everything else will be hexcoded string
    if (Buffer.isBuffer(v)) return '0x' + v.toString('hex')
    if (v && v.ixor) return '0x' + v.toString(16)
    return v[1] !== 'x' ? '0x' + v : v
}

function decodeResult(types: string[], result: Buffer): any {
    return rawDecode(types, result).map((v, i) => convertToType(types[i], v))
}

function createCallParams(method: string, values: any[]): { txdata: string, convert: (a: any) => any } {
    if (!method) throw new Error('method needs to be a valid contract method signature')
    if (method.indexOf('(') < 0) method += '()'
    const methodRegex = /^\w+\((.*)\)$/gm
    let convert = null

    if (method.indexOf(':') > 0) {
        const srcFullMethod = method;
        const retTypes = method.split(':')[1].substr(1).replace(')', ' ').trim().split(',');
        convert = result => {
            if (result) result = decodeResult(retTypes, Buffer.from(result.substr(2), 'hex'))
            if (Array.isArray(result) && (!srcFullMethod.endsWith(')') || result.length == 1))
                result = result[0]
            return result
        }
        method = method.substr(0, method.indexOf(':'))
    }

    const m = methodRegex.exec(method)
    if (!m) throw new Error('No valid method signature for ' + method)
    const types = m[1].split(',').filter(_ => _)
    if (values.length < types.length) throw new Error('invalid number of arguments. Must be at least ' + types.length)
    values.forEach((v, i) => {
        if (types[i] === 'bytes') values[i] = toBuffer(v)
    })

    return {
        txdata: '0x' + (values.length
            ? encodeFunction(method, values)
            : methodID(method.substr(0, method.indexOf('(')), []).toString('hex'))
        , convert
    }
}

export function createSignatureHash(def: ABI) {
    return keccak(def.name + createSignature(def.inputs))
}

export function createSignature(fields: ABIField[]): string {
    return '(' + fields.map(f => {
        let baseType = f.type
        const t = baseType.indexOf('[')
        if (t > 0) baseType = baseType.substr(0, t)
        if (baseType === 'uint' || baseType === 'int') baseType += '256'
        return baseType + (t < 0 ? '' : f.type.substr(t))
    }).join(',') + ')'
}
function parseABIString(def: string): ABI {
    const [name, args] = def.split(/[\(\)]/)
    return {
        name, type: 'event', inputs: args.split(',').filter(_ => _).map(_ => _.split(' ').filter(z => z)).map(_ => ({
            type: _[0],
            name: _[_.length - 1],
            indexed: _[1] == 'indexed'
        }))
    }
}

function decodeEventData(log: Log, def: string | { _eventHashes: any }): any {
    let d: ABI = (typeof def === 'object') ? def._eventHashes[log.topics[0]] : parseABIString(def)
    if (!d) return null//throw new Error('Could not find the ABI')
    return decodeEvent(log, d)
}
export function decodeEvent(log: Log, d: ABI): any {
    const indexed = d.inputs.filter(_ => _.indexed), unindexed = d.inputs.filter(_ => !_.indexed), r: any = { event: d && d.name }
    if (indexed.length)
        decodeResult(indexed.map(_ => _.type), Buffer.concat(log.topics.slice(1).map(bytes))).forEach((v, i) => r[indexed[i].name] = v)
    if (unindexed.length)
        decodeResult(unindexed.map(_ => _.type), bytes(log.data)).forEach((v, i) => r[unindexed[i].name] = v)
    return r
}


export class SimpleSigner implements Signer {
    accounts: { [ac: string]: Hash }

    constructor(...pks: Hash[]) {
        this.accounts = {}
        if (pks) pks.forEach(_ => this.addAccount(_))
    }

    addAccount(pk: Hash) {
        const adr: Address = toChecksumAddress(toHex(privateToAddress(toBuffer(pk))))
        this.accounts[adr] = pk
        return adr
    }


    async hasAccount(account: string): Promise<boolean> {
        return !!this.accounts[toChecksumAddress(account)]
    }

    async sign(data: Buffer, account: string): Promise<Signature> {
        const pk = toBuffer(this.accounts[toChecksumAddress(account)])
        if (!pk || pk.length != 32) throw new Error('Account not found for signing ' + account)
        const sig = ecsign(data, pk)
        return { messageHash: toHex(data), v: toHex(sig.v), r: toHex(sig.r), s: toHex(sig.s), message: toHex(data) }
    }

}


export function soliditySha3(...args: any[]): string {
    return toHex(keccak(rawEncode(args.map(_ => {
        switch (typeof (_)) {
            case 'number':
                return _ < 0 ? 'int256' : 'uint256'
            case 'string':
                return _.substr(0, 2) === '0x' ? 'bytes' : 'string'
            case 'boolean':
                return 'bool'
            default:
                return BN.isBN(_) ? 'uint256' : 'bytes'
        }
    }), args)))
}

function toHexBlock(b: any): string {
    return typeof b === 'string' ? b : toMinHex(b)
}

export function encodeFunction(signature: string, args: any[]): string {
    const inputParams = signature.split(':')[0]

    const abiCoder = new AbiCoder()

    const typeTemp = inputParams.substring(inputParams.indexOf('(') + 1, (inputParams.indexOf(')')))

    const typeArray = typeTemp.length > 0 ? typeTemp.split(",") : []
    const methodHash = (methodID(signature.substr(0, signature.indexOf('(')), typeArray)).toString('hex')

    return methodHash + abiCoder.encode(typeArray, args).substr(2)
}

export function decodeFunction(signature: string, args: Buffer | RPCResponse): any {
    const outputParams = signature.split(':')[1]

    const abiCoder = new AbiCoder()

    const typeTemp = outputParams.substring(outputParams.indexOf('(') + 1, (outputParams.indexOf(')')))

    const typeArray = typeTemp.length > 0 ? typeTemp.split(",") : []

    return abiCoder.decode(typeArray, toBuffer(args))
}